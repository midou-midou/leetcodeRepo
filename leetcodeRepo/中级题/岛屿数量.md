# 岛屿数量  

### 题目要求:  

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。



#### 示例:  

```js  

输入：grid = [
  ['1','1','1','1','0'],
  ['1','1','0','1','0'],
  ['1','1','0','0','0'],
  ['0','0','0','0','0']
]
输出：1  

```  

### 思路:  

首先，得一个一个方格找，这点得清楚  

难点在于找到岛屿边界要停下来，这个难点得用递归解，如果从第一个`1`方块开始递归，就要从这个方块的上、下、左、右四个方向找紧邻的`1`方块（根据题目，这是连到一块的一片岛屿），当碰到`0`即为边界，终止递归就行  

可能会有疑问，如果递归一直往下找，会先碰到`0`跳出递归。所以为了避免这种情况，得记录已经遍历过的`1`地块，可以把它放到一个`path`的set里，最外层循环`grid`时要判断下是否已经遍历过`isThrough`方法

```js  

/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
    let res = 0
    let path = new Set()

    // 判断当前格子是否已经走过
    const isThrough = ([i, j]) => {
        return path.has(`${i},${j}`)
    }

    // 寻找下一个可以走的格子
    const findNext = (last = []) => {
        let [i, j] = last
        let next = []

        if (i - 1 >= 0 && grid[i - 1][j] !== '0' && !isThrough([i - 1, j])) {
            next.push([i - 1, j])
            path.add(`${i - 1},${j}`)
        }

        if (i + 1 < grid.length && grid[i + 1][j] !== '0' && !isThrough([i + 1, j])) {
            next.push([i + 1, j])
            path.add(`${i + 1},${j}`)
        }

        if (j - 1 >= 0 && grid[i][j - 1] !== '0' && !isThrough([i, j - 1])) {
            next.push([i, j - 1])
            path.add(`${i},${j - 1}`)
        }

        if (j + 1 < grid[i].length && grid[i][j + 1] !== '0' && !isThrough([i, j + 1])) {
            next.push([i, j + 1])
            path.add(`${i},${j + 1}`)
        }

        return next
    }
    
    // 从last位置开始
    // 递归遍历当前这一片岛屿的所有格子
    const findIsland = (last = []) => {
        let next = findNext(last)
        for (let n of next) {
            findIsland(n)
        }
    }


    for (let i = 0; i < grid.length; i++) {
        for (let j = 0; j < grid[i].length; j++) {
            if (grid[i][j] === '0') {
                continue
            } else if (!isThrough([i, j])) {
                findIsland([i, j])
                res += 1
            }
        }
    }

    return res
};

```  
